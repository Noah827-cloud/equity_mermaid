<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mermaid é¢„è§ˆå™¨ï¼ˆåŒå‡»åŒæ­¥ä¿®æ”¹ä»£ç ï½œå¢å¼ºç‰ˆï¼‰</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    .header {
      padding: 12px 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .controls input {
      padding: 4px 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .controls button {
      padding: 4px 10px;
      font-size: 14px;
      cursor: pointer;
    }
    .container {
      display: flex;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    #editor {
      height: 100%;
      min-width: 300px;
      max-width: 70%;
      display: flex;
      flex-direction: column;
    }
    #preview-container {
      flex: 1;
      min-width: 300px;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: white;
      overflow: hidden;
    }
    textarea {
      flex: 1;
      padding: 14px;
      font-family: 'Consolas', monospace;
      font-size: 13px;
      line-height: 1.4;
      border: none;
      outline: none;
      resize: none;
      background: #fff;
    }
    #preview {
      flex: 1;
      padding: 20px;
      overflow: hidden;
      display: flex;
      justify-content: flex-start;
      align-items: flex-start;
      position: relative;
      cursor: default;
    }
    #preview svg {
      min-width: 100%;
      height: auto;
      max-width: none;
      cursor: pointer;
    }
    #preview svg text {
      cursor: pointer;
      user-select: none;
    }
    #preview svg text:hover {
      fill: #1976d2 !important;
      font-weight: bold !important;
    }

    /* æ‹–æ‹½æ—¶çš„å…‰æ ‡æ ·å¼ */
    #preview.dragging {
      cursor: grab;
    }
    #preview.dragging svg {
      cursor: grabbing !important;
    }

    #resizer {
      width: 6px;
      background: #e0e0e0;
      cursor: col-resize;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #resizer:hover { background: #ccc; }
    #resizer::after {
      content: "â‹®â‹®";
      color: #999;
      font-size: 14px;
      writing-mode: vertical-rl;
    }
    .error {
      padding: 10px;
      color: #d32f2f;
      background: #ffebee;
      font-family: monospace;
      white-space: pre-wrap;
    }
    .fullscreen #editor,
    .fullscreen #resizer {
      display: none;
    }
    .fullscreen .container {
      height: calc(100vh - 60px);
    }
  </style>
</head>
<body>
  <div class="header">
    ğŸ“Š Mermaid é¢„è§ˆå™¨ï¼ˆåŒå‡»èŠ‚ç‚¹åŒæ­¥ä¿®æ”¹ä»£ç ï½œå¢å¼ºå…¼å®¹æ€§ï¼‰
    <div class="controls">
      <input type="text" id="keywordInput" placeholder="è¾“å…¥å…³é”®è¯é«˜äº®" value="Shanghai">
      <button id="highlightBtn">é«˜äº®</button>
      <button id="clearBtn">æ¸…é™¤é«˜äº®</button>
      <button id="fullscreenBtn">å…¨å±é¢„è§ˆ</button>
    </div>
  </div>
  <div class="container">
    <div id="editor">
      <textarea id="source" spellcheck="false"></textarea>
    </div>
    <div id="resizer"></div>
    <div id="preview-container">
      <div id="preview"></div>
    </div>
  </div>

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';

    mermaid.initialize({
      startOnLoad: false,
      theme: 'default',
      securityLevel: 'antiscript',
      flowchart: {
        useMaxWidth: false,
        htmlLabels: false,
        curve: 'linear'  // ç›´è§’è¿çº¿
      },
      fontFamily: '"Segoe UI", sans-serif'
    });

    const source = document.getElementById('source');
    const preview = document.getElementById('preview');
    const editor = document.getElementById('editor');
    const resizer = document.getElementById('resizer');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const keywordInput = document.getElementById('keywordInput');
    const highlightBtn = document.getElementById('highlightBtn');
    const clearBtn = document.getElementById('clearBtn');

    let currentSvgEl = null;
    let isFullscreen = false;
    let scale = 1;
    let translateX = 0;
    let translateY = 0;

    editor.style.width = '30%';

    // ========== å·¥å…·å‡½æ•° ==========
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // é€šè¿‡ nodeId + oldText ç²¾å‡†æ›¿æ¢
    function updateMermaidCodeByNodeId(nodeId, oldText, newText) {
      const code = source.value;
      const escapedOld = escapeRegExp(oldText);
      const patterns = [
        `(${escapeRegExp(nodeId)}\
$$
")${escapedOld}("])`,
        `(${escapeRegExp(nodeId)}\$")${escapedOld}("\$)`,
        `(${escapeRegExp(nodeId)}\\{")${escapedOld}("\})`
      ];

      for (const pattern of patterns) {
        const regex = new RegExp(pattern, 'g');
        const newCode = code.replace(regex, `$1${newText}$2`);
        if (newCode !== code) {
          source.value = newCode;
          render();
          return true;
        }
      }

      // å®½æ¾åŒ¹é…ï¼ˆå…è®¸ç©ºæ ¼ã€æ··åˆå¼•å·ï¼‰
      const looseRegex = new RegExp(
        `(${escapeRegExp(nodeId)}\\s*[\\[\$\\{]\\s*["'])${escapedOld}(["']\\s*[\
$$
\$\\}])`, 'g'
      );
      const newCode = code.replace(looseRegex, `$1${newText}$2`);
      if (newCode !== code) {
        source.value = newCode;
        render();
        return true;
      }

      return false;
    }

    // é€šè¿‡å…¨æ–‡æœ¬åŒ¹é…ï¼ˆä»…å½“ oldText å”¯ä¸€å‡ºç°ä¸€æ¬¡æ—¶æ‰æ›¿æ¢ï¼‰
    function updateMermaidCodeByText(oldText, newText) {
      const code = source.value;
      const escapedOld = escapeRegExp(oldText);
      const quoteRegex = new RegExp(`(["'])${escapedOld}\\1`, 'g');
      const allMatches = [...code.matchAll(new RegExp(`(["'])${escapedOld}\\1`, 'g'))];

      if (allMatches.length !== 1) {
        return false; // ä¸å”¯ä¸€ï¼Œä¸å®‰å…¨
      }

      const newCode = code.replace(quoteRegex, `$1${newText}$1`);
      if (newCode !== code) {
        source.value = newCode;
        render();
        return true;
      }
      return false;
    }

    // ========== æ¸²æŸ“å‡½æ•° ==========
    async function render() {
      const code = source.value.trim();
      preview.innerHTML = '';

      if (!code) {
        preview.textContent = 'è¯·è¾“å…¥ Mermaid ä»£ç ...';
        currentSvgEl = null;
        return;
      }

      try {
        const { svg: rawSvg } = await mermaid.render('chart', code);
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(rawSvg, 'image/svg+xml');
        currentSvgEl = svgDoc.documentElement;

        preview.innerHTML = '';
        preview.appendChild(currentSvgEl);

        applyTransform();

        // === ç»‘å®šåŒå‡»äº‹ä»¶ï¼ˆå¢å¼ºç‰ˆï¼‰===
        const texts = currentSvgEl.querySelectorAll('text');
        texts.forEach(text => {
          text.style.cursor = 'pointer';

          // æ›´å®½æ¾çš„ nodeId æå–ï¼šæ”¯æŒä¸­æ–‡ã€è¿å­—ç¬¦ã€ç‚¹ã€ä¸‹åˆ’çº¿
          let nodeId = '';
          let g = text.closest('g');
          if (g && g.id) {
            const match = g.id.match(/flowchart-([A-Za-z0-9_\u4e00-\u9fa5\-\.]+?)(?:-\d+)?$/);
            if (match) nodeId = match[1];
          }
          text.setAttribute('data-node-id', nodeId || 'unknown');
          text.setAttribute('data-original-text', text.textContent || '');

          const onDblClick = () => {
            const oldText = text.getAttribute('data-original-text') || text.textContent;
            const nodeId = text.getAttribute('data-node-id');
            const newText = prompt('è¯·è¾“å…¥æ–°èŠ‚ç‚¹æ–‡å­—ï¼š', oldText);
            if (newText === null || newText === oldText) return;

            // æ›´æ–° SVG
            text.textContent = newText;
            text.setAttribute('data-original-text', newText);
            const rect = text.closest('g')?.querySelector('rect');
            if (rect) {
              const x = parseFloat(rect.getAttribute('x')) || 0;
              const width = parseFloat(rect.getAttribute('width')) || 0;
              text.setAttribute('x', x + width / 2);
              text.setAttribute('text-anchor', 'middle');
            }

            // å°è¯•æ›´æ–°ä»£ç 
            let updated = false;
            if (nodeId && nodeId !== 'unknown') {
              updated = updateMermaidCodeByNodeId(nodeId, oldText, newText);
            }
            if (!updated) {
              updated = updateMermaidCodeByText(oldText, newText);
            }
            if (!updated) {
              alert('æœªèƒ½è‡ªåŠ¨æ›´æ–°ä»£ç ï¼Œè¯·æ‰‹åŠ¨ä¿®æ”¹å·¦ä¾§ Mermaid å†…å®¹ã€‚');
            }
          };

          text.removeEventListener('dblclick', onDblClick);
          text.addEventListener('dblclick', onDblClick);
        });

      } catch (e) {
        console.error(e);
        preview.innerHTML = `<div class="error">âŒ ${e.message || e}</div>`;
        currentSvgEl = null;
      }
    }

    function applyTransform() {
      if (currentSvgEl) {
        currentSvgEl.style.transformOrigin = '0 0';
        currentSvgEl.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
      }
    }

    // ========== é«˜äº®å‡½æ•° ==========
    function highlightKeyword(keyword) {
      if (!currentSvgEl || !keyword.trim()) return;
      render();
      setTimeout(() => {
        if (!currentSvgEl) return;
        const groups = currentSvgEl.querySelectorAll('g');
        groups.forEach(g => {
          const texts = g.querySelectorAll('text');
          let match = false;
          texts.forEach(t => {
            if ((t.textContent || '').includes(keyword)) {
              match = true;
            }
          });
          if (match) {
            texts.forEach(t => {
              t.setAttribute('fill', '#d32f2f');
              t.setAttribute('font-weight', 'bold');
            });
            const rect = g.querySelector('rect');
            if (rect) {
              rect.setAttribute('fill', '#ffebee');
              rect.setAttribute('stroke', '#f44336');
              rect.setAttribute('stroke-width', '2');
            }
          }
        });
      }, 50);
    }

    function clearHighlight() {
      render();
    }

    // åˆå§‹ä»£ç 
    source.value = `flowchart TD
    A["ç”°æ¡‘"] -->|51.3287%| B["æ¡‘æœå¥åº·ç§‘æŠ€å‘å±•ï¼ˆä¸Šæµ·ï¼‰æœ‰é™å…¬å¸"]
    SH1["ä¸Šæµ·æ¡‘æ¯”ç§‘æŠ€åˆä¼™ä¼ä¸šï¼ˆæœ‰é™åˆä¼™ï¼‰"] -->|22.6713%| B
    SH2["ä¸Šæµ·é¸¿ä¿ä¿¡æ¯æŠ€æœ¯ä¸­å¿ƒï¼ˆæœ‰é™åˆä¼™ï¼‰"] -->|20.0000%| B
    SH3["ä¸Šæµ·æ—¶æ¡‘ç§‘æŠ€åˆä¼™ä¼ä¸šï¼ˆæœ‰é™åˆä¼™ï¼‰"] -->|6.0000%| B
    B -->|100%| SUB1["æ¡‘æœï¼ˆä¸Šæµ·ï¼‰ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸"]
    B -->|100%| SUB2["æˆéƒ½åŒæµæ¡‘æœäº’è”ç½‘åŒ»é™¢æœ‰é™å…¬å¸"]
    B -->|70%| SUB3["æ¡‘æœå¥åº·ç§‘æŠ€å‘å±•ï¼ˆæ— é”¡ï¼‰æœ‰é™å…¬å¸"]
    B -->|60%| SUB4["æµ·å—æ¡‘æœå¥åº·ç§‘æŠ€æœ‰é™å…¬å¸"]
    B -->|5%| SUB5["ä¸Šæµ·æŸé’å¥åº·ç§‘æŠ€æœ‰é™å…¬å¸"]

    classDef person fill:#ffebee,stroke:#f44336;
    classDef company fill:#bbdefb,stroke:#1976d2;
    classDef sub fill:#e0f7fa,stroke:#00bcd4;
    class A person
    class B company
    class SUB1,SUB2,SUB3,SUB4,SUB5 sub`;

    // ========== æ‹–æ‹½å¹³ç§»é€»è¾‘ ==========
    let isDragging = false;
    let startX, startY, startTranslateX, startTranslateY;

    preview.addEventListener('mousedown', (e) => {
      if (!isFullscreen) return;
      if (e.target.tagName === 'text') return; // æ–‡å­—ä»å¯åŒå‡»ç¼–è¾‘

      isDragging = true;
      preview.classList.add('dragging');
      startX = e.clientX;
      startY = e.clientY;
      startTranslateX = translateX;
      startTranslateY = translateY;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging || !isFullscreen) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      translateX = startTranslateX + dx;
      translateY = startTranslateY + dy;
      applyTransform();
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        preview.classList.remove('dragging');
      }
    });

    // ========== äº‹ä»¶ç»‘å®š ==========
    let timer;
    source.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(render, 400);
    });

    highlightBtn.addEventListener('click', () => {
      highlightKeyword(keywordInput.value);
    });

    clearBtn.addEventListener('click', () => {
      clearHighlight();
    });

    keywordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') highlightKeyword(keywordInput.value);
    });

    // æ‹–æ‹½åˆ†å‰²æ¡
    let isResizing = false;
    resizer.addEventListener('mousedown', (e) => {
      isResizing = true;
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      const containerRect = document.querySelector('.container').getBoundingClientRect();
      let leftPercent = ((e.clientX - containerRect.left) / containerRect.width) * 100;
      leftPercent = Math.max(10, Math.min(70, leftPercent));
      editor.style.width = `${leftPercent}%`;
      render();
    });
    document.addEventListener('mouseup', () => {
      isResizing = false;
      document.body.style.cursor = 'default';
    });

    // å…¨å±åˆ‡æ¢
    fullscreenBtn.addEventListener('click', () => {
      document.body.classList.toggle('fullscreen');
      isFullscreen = !isFullscreen;
      fullscreenBtn.textContent = isFullscreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±é¢„è§ˆ';
      render();

      if (!isFullscreen) {
        translateX = 0;
        translateY = 0;
        applyTransform();
      }
    });

    // Ctrl + æ»šè½®ç¼©æ”¾
    preview.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        scale = Math.max(0.2, Math.min(scale + delta, 3));
        applyTransform();
      }
    }, { passive: false });

    // åˆå§‹æ¸²æŸ“
    render();
  </script>
</body>
</html>