<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>股权图谱布局预览（中心向外按比例）</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #network { width: 100%; height: 100vh; border-top: 1px solid #eee; }
    .legend {
      position: fixed; top: 10px; left: 10px; background: #fff; border: 1px solid #e5e7eb;
      border-radius: 8px; padding: 10px 12px; font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto;
      box-shadow: 0 6px 16px rgba(0,0,0,.08); font-size: 12px; color: #374151;
    }
    .legend b { color: #111827; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/vis-network/styles/vis-network.min.css" />
</head>
<body>
  <div class="legend">
    <div><b>布局规则</b>：每层“最大居中，右大左小”，间距≥220px</div>
    <div>多父节点锚定最大比例父节点；无比例按 0 处理，靠左</div>
  </div>
  <div id="network"></div>

  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
  // 将此对象替换为你的 JSON（equity_data 部分）
  const dataJson = {
    "core_company": "山东蓝电电力有限公司",
    "top_level_entities": [
      {"name":"力诺电力集团股份有限公司","type":"company","percentage":70.0},
      {"name":"力诺投资控股集团有限公司","type":"company","percentage":70.0},
      {"name":"力诺集团股份有限公司","type":"company","percentage":78.8714},
      {"name":"青岛富之祥新能源投资发展合伙企业（有限合伙）","type":"company","percentage":5.41},
      {"name":"济南荣舜企业管理咨询合伙企业（有限合伙）","type":"company","percentage":3.5},
      {"name":"济南儒泉企业管理咨询合伙企业（有限合伙）","type":"company","percentage":3.5},
      {"name":"济南金投股权投资有限公司","type":"company","percentage":13.25},
      {"name":"济南金投控股集团有限公司","type":"company","percentage":5.9101},
      {"name":"山东力诺物流有限公司","type":"company","percentage":1.9685},
      {"name":"高元坤","type":"person","percentage":80.0},
      {"name":"申英明","type":"person","percentage":20.0},
      {"name":"力诺集团（上海）有限公司","type":"company","percentage":100.0},
      {"name":"武汉双虎涂料股份有限公司","type":"company","percentage":72.7273},
      {"name":"山东力诺太阳能电力股份有限公司","type":"company","percentage":98.1212},
      {"name":"山东力诺医药包装股份有限公司","type":"company","percentage":33.0533},
      {"name":"山东科源制药股份有限公司","type":"company","percentage":34.3891},
      {"name":"山东宏济堂制药集团股份有限公司","type":"company","percentage":74.938}
    ],
    "entity_relationships": [
      {"parent":"力诺电力集团股份有限公司","child":"山东蓝电电力有限公司","percentage":100.0,"relationship_type":"持股","description":"持股100.0%"},
      {"parent":"力诺投资控股集团有限公司","child":"力诺电力集团股份有限公司","percentage":70.0,"relationship_type":"持股","description":"持股70.0%"},
      {"parent":"力诺集团股份有限公司","child":"力诺电力集团股份有限公司","percentage":16.13,"relationship_type":"持股","description":"持股16.13%"},
      {"parent":"青岛富之祥新能源投资发展合伙企业（有限合伙）","child":"力诺电力集团股份有限公司","percentage":5.41,"relationship_type":"持股","description":"持股5.41%"},
      {"parent":"济南荣舜企业管理咨询合伙企业（有限合伙）","child":"力诺电力集团股份有限公司","percentage":3.5,"relationship_type":"持股","description":"持股3.5%"},
      {"parent":"济南儒泉企业管理咨询合伙企业（有限合伙）","child":"力诺电力集团股份有限公司","percentage":3.5,"relationship_type":"持股","description":"持股3.5%"},
      {"parent":"力诺集团股份有限公司","child":"力诺投资控股集团有限公司","percentage":78.8714,"relationship_type":"持股","description":"持股78.8714%"},
      {"parent":"济南金投股权投资有限公司","child":"力诺投资控股集团有限公司","percentage":13.25,"relationship_type":"持股","description":"持股13.25%"},
      {"parent":"济南金投控股集团有限公司","child":"力诺投资控股集团有限公司","percentage":5.9101,"relationship_type":"持股","description":"持股5.9101%"},
      {"parent":"山东力诺物流有限公司","child":"力诺投资控股集团有限公司","percentage":1.9685,"relationship_type":"持股","description":"持股1.9685%"},
      {"parent":"高元坤","child":"力诺集团股份有限公司","percentage":80.0,"relationship_type":"持股","description":"持股80.0%"},
      {"parent":"申英明","child":"力诺集团股份有限公司","percentage":20.0,"relationship_type":"持股","description":"持股20.0%"},
      {"parent":"力诺集团股份有限公司","child":"力诺集团（上海）有限公司","percentage":100.0,"relationship_type":"控股","description":"对外投资100.0%"},
      {"parent":"力诺集团股份有限公司","child":"武汉双虎涂料股份有限公司","percentage":72.7273,"relationship_type":"控股","description":"对外投资72.7273%"},
      {"parent":"力诺集团股份有限公司","child":"山东力诺太阳能电力股份有限公司","percentage":98.1212,"relationship_type":"控股","description":"对外投资98.1212%"},
      {"parent":"力诺投资控股集团有限公司","child":"山东力诺医药包装股份有限公司","percentage":33.0533,"relationship_type":"控股","description":"对外投资33.0533%"},
      {"parent":"力诺投资控股集团有限公司","child":"山东科源制药股份有限公司","percentage":34.3891,"relationship_type":"控股","description":"对外投资34.3891%"},
      {"parent":"力诺投资控股集团有限公司","child":"山东宏济堂制药集团股份有限公司","percentage":74.938,"relationship_type":"控股","description":"对外投资74.938%"}
    ],
    "control_relationships": [],
    "all_entities": [
      {"name":"山东蓝电电力有限公司","type":"company"},
      {"name":"力诺电力集团股份有限公司","type":"company"},
      {"name":"力诺投资控股集团有限公司","type":"company"},
      {"name":"力诺集团股份有限公司","type":"company"},
      {"name":"青岛富之祥新能源投资发展合伙企业（有限合伙）","type":"company"},
      {"name":"济南荣舜企业管理咨询合伙企业（有限合伙）","type":"company"},
      {"name":"济南儒泉企业管理咨询合伙企业（有限合伙）","type":"company"},
      {"name":"济南金投股权投资有限公司","type":"company"},
      {"name":"济南金投控股集团有限公司","type":"company"},
      {"name":"山东力诺物流有限公司","type":"company"},
      {"name":"高元坤","type":"person"},
      {"name":"申英明","type":"person"},
      {"name":"力诺集团（上海）有限公司","type":"company"},
      {"name":"武汉双虎涂料股份有限公司","type":"company"},
      {"name":"山东力诺太阳能电力股份有限公司","type":"company"},
      {"name":"山东力诺医药包装股份有限公司","type":"company"},
      {"name":"山东科源制药股份有限公司","type":"company"},
      {"name":"山东宏济堂制药集团股份有限公司","type":"company"}
    ]
  };

  // ------- 帮助函数 -------
  function parsePct(v) {
    if (v === null || v === undefined) return 0;
    const s = String(v).trim();
    const m = s.match(/-?\d+(\.\d+)?/);
    return m ? parseFloat(m[0]) : 0;
  }

  // 建图：节点、入度、父子索引
  function buildGraph(data) {
    const entities = new Map();
    (data.all_entities || []).forEach(e => entities.set(e.name, { name: e.name, type: e.type || 'company' }));
    // 确保关系中的实体也都存在
    (data.entity_relationships || []).forEach(r => {
      if (!entities.has(r.parent)) entities.set(r.parent, { name: r.parent, type: 'company' });
      if (!entities.has(r.child)) entities.set(r.child, { name: r.child, type: 'company' });
    });

    const childrenOf = new Map(); // parent -> [{child, pct}]
    const parentsOf = new Map();  // child -> [{parent, pct}]
    const indeg = new Map();      // name -> indegree
    entities.forEach((_, name) => indeg.set(name, 0));

    (data.entity_relationships || []).forEach(rel => {
      const p = rel.parent, c = rel.child, pct = parsePct(rel.percentage);
      if (!childrenOf.has(p)) childrenOf.set(p, []);
      childrenOf.get(p).push({ child: c, pct });
      if (!parentsOf.has(c)) parentsOf.set(c, []);
      parentsOf.get(c).push({ parent: p, pct });
      indeg.set(c, (indeg.get(c) || 0) + 1);
    });

    return { entities, childrenOf, parentsOf, indeg };
  }

  // 选择锚定父节点（多父节点取最大比例父）
  function anchorParentFor(child, parentsOf) {
    const pls = parentsOf.get(child) || [];
    if (pls.length === 0) return null;
    let best = pls[0];
    for (const p of pls) if (p.pct > best.pct) best = p;
    return best.parent;
  }

  // 构建层（自上而下），level 0 = 入度为 0 的节点
  function buildLevels(entities, childrenOf, indeg) {
    const levels = [];
    const q = [];
    const indegCopy = new Map(indeg);
    indegCopy.forEach((d, name) => { if (d === 0) q.push(name); });
    const seen = new Set();
    while (q.length) {
      const lvlCount = q.length;
      const level = [];
      for (let i = 0; i < lvlCount; i++) {
        const u = q.shift();
        if (seen.has(u)) continue;
        seen.add(u);
        level.push(u);
        const ch = childrenOf.get(u) || [];
        for (const { child } of ch) {
          indegCopy.set(child, (indegCopy.get(child) || 0) - 1);
          if (indegCopy.get(child) === 0) q.push(child);
        }
      }
      if (level.length) levels.push(level);
    }
    // 兜底：未覆盖的节点放最后一层
    const leftover = [];
    entities.forEach((_, name) => { if (!seen.has(name)) leftover.push(name); });
    if (leftover.length) levels.push(leftover);
    return levels;
  }

  // 兄弟“中心向外”顺序
  function centerOutOrder(items, getPct) {
    const arr = [...items].sort((a, b) => getPct(b) - getPct(a)); // desc
    if (arr.length <= 2) return arr;
    const res = [arr[0]];
    let L = 1, R = 2;
    let right = true;
    while (L < arr.length || R < arr.length) {
      if (right && R < arr.length) { res.push(arr[R]); R += 2; }
      if (!right && L < arr.length) { res.push(arr[L]); L += 2; }
      right = !right;
    }
    return res;
  }

  // 布局计算（返回 nodes, edges）
  function layout(data) {
    const GAP = 220;            // 水平最小间距
    const LEVEL_Y = 180;        // 层距
    const { entities, childrenOf, parentsOf, indeg } = buildGraph(data);
    const levels = buildLevels(entities, childrenOf, indeg);

    // parent->child 的边，附带 roundness 基于相对偏移
    const edges = [];
    (data.entity_relationships || []).forEach(rel => {
      edges.push({
        from: rel.parent,
        to: rel.child,
        label: (rel.percentage != null ? (parsePct(rel.percentage).toFixed(2) + '%') : ''),
      });
    });

    // 放置坐标：从上往下
    const nodePos = new Map(); // name -> {x,y}
    // level 0：用中心向外按出边最大值排序
    if (levels.length) {
      const lvl0 = levels[0];
      const byOutPct = (name) => {
        const ch = childrenOf.get(name) || [];
        let mx = 0;
        for (const { pct } of ch) { if (pct > mx) mx = pct; }
        return mx;
      };
      const ord0 = centerOutOrder(lvl0, byOutPct);
      const startX = -(ord0.length - 1) * GAP / 2;
      ord0.forEach((name, i) => nodePos.set(name, { x: startX + i * GAP, y: 0 }));
    }

    // 其余层：按锚定父分组，再对组内“中心向外”
    for (let li = 1; li < levels.length; li++) {
      const lvl = levels[li];
      // parent -> [childs]
      const groups = new Map();
      for (const name of lvl) {
        const anchor = anchorParentFor(name, parentsOf); // 允许 null
        const key = anchor || '__no_parent__';
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(name);
      }
      // 组块放置：围绕父节点 x，对组内“中心向外”，合并时避免重叠
      // 先准备父 x（无父的用 0）
      const blocks = [];
      groups.forEach((arr, parent) => {
        const getPct = (n) => {
          const pls = parentsOf.get(n) || [];
          // 找到锚定父的 pct；找不到就取最大；无则 0
          let pct = 0;
          if (parent && parent !== '__no_parent__') {
            for (const p of pls) if (p.parent === parent) { pct = p.pct; break; }
          } else {
            for (const p of pls) if (p.pct > pct) pct = p.pct;
          }
          return pct; // 缺失默认 0
        };
        const ordered = centerOutOrder(arr, getPct);
        const px = nodePos.get(parent)?.x ?? 0;
        // 组内定位（以 parent x 为中心）
        const localXs = [];
        const start = px - (ordered.length - 1) * GAP / 2;
        ordered.forEach((n, i) => localXs.push({ name: n, x: start + i * GAP, pct: getPct(n) }));
        // block 宽度
        const minX = Math.min(...localXs.map(o => o.x));
        const maxX = Math.max(...localXs.map(o => o.x));
        blocks.push({ parent, nodes: localXs, minX, maxX, center: px });
      });

      // 合并块时避免互相压重：按 parent center 排序，从左到右扫描微调
      blocks.sort((a, b) => a.center - b.center);
      for (let i = 1; i < blocks.length; i++) {
        const prev = blocks[i - 1], cur = blocks[i];
        if (cur.minX - prev.maxX < GAP) {
          const shift = (prev.maxX + GAP) - cur.minX;
          cur.nodes.forEach(o => o.x += shift);
          cur.minX += shift; cur.maxX += shift; cur.center += shift;
        }
      }
      // 写入位置
      blocks.forEach(block => {
        block.nodes.forEach(o => nodePos.set(o.name, { x: o.x, y: li * LEVEL_Y }));
      });
    }

    // 生成 vis 数据
    const nodes = [];
    entities.forEach((e, name) => {
      const pos = nodePos.get(name) || { x: 0, y: levels.length * 180 };
      const isPerson = e.type === 'person';
      nodes.push({
        id: name,
        label: name,
        x: pos.x, y: pos.y,
        shape: isPerson ? 'box' : 'ellipse',
        color: isPerson ? { background: '#fff7ed', border: '#fb923c' } : { background: '#eef2ff', border: '#6366f1' },
        borderWidth: 1,
        font: { multi: true, size: 14 }
      });
    });

    // 为边附上平滑参数（基于左右偏移）
    const edgesOut = edges.map(e => {
      const fromX = nodePos.get(e.from)?.x ?? 0;
      const toX = nodePos.get(e.to)?.x ?? 0;
      const dx = toX - fromX;
      const right = dx >= 0;
      const roundness = Math.min(0.45, Math.abs(dx) / 1200); // 位移越大弯曲越明显，封顶
      return {
        from: e.from, to: e.to, label: e.label,
        arrows: 'to',
        smooth: { enabled: true, type: right ? 'curvedCW' : 'curvedCCW', roundness }
      };
    });

    return { nodes, edges: edgesOut };
  }

  // 渲染
  (function render() {
    const { nodes, edges } = layout(dataJson);
    const container = document.getElementById('network');
    const network = new vis.Network(container, {
      nodes: new vis.DataSet(nodes),
      edges: new vis.DataSet(edges)
    }, {
      physics: false, // 我们已手工定位
      interaction: { hover: true, tooltipDelay: 120 },
      edges: {
        font: { align: 'top', size: 11, color: '#6b7280' },
        color: { color: '#94a3b8' }
      },
      nodes: {
        margin: 8
      }
    });
  })();
  </script>
</body>
</html>