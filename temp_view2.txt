            # 子公司导入是否自动判断实体类型
            auto_detect_sub_type = st.checkbox("启用自动类型判断（子公司）", value=True, help="根据名称自动判断是公司还是个人")

            # 让用户设置是否跳过表头行
            skip_rows_sub = st.number_input(
                    "跳过前几行（如果有表头或说明文字）", 
                    min_value=0, 
                    max_value=10, 
                    value=0, 
                    step=1
                )
                
            # 导入按钮
            if st.button("开始导入子公司", type="primary"):
                # 添加导入过程的日志（内部日志，不全部显示在界面）
                import logging
                logging.basicConfig(level=logging.INFO)
                logger = logging.getLogger("excel_subsidiary_import")
                
                # 显示正在处理的信息
                processing_placeholder = st.info("正在处理导入...")
                
                # 保存原始列索引而不是列名
                name_col_index = list(df_sub.columns).index(name_col_selected_sub)
                percentage_col_index = list(df_sub.columns).index(percentage_col_selected_sub)
                
                # 重新读取并跳过指定的行数
                df_processing = None
                try:
                        if skip_rows_sub > 0:
                            df_processing = pd.read_excel(uploaded_file_sub, skiprows=skip_rows_sub)
                            # 再次处理列名
                            if any('Unnamed' in str(col) for col in df_processing.columns):
                                df_processing.columns = [f'Column_{i}' for i in range(len(df_processing.columns))]
                        else:
                            # 如果不跳过行，直接使用原始数据
                            df_processing = df_sub.copy()
                except Exception as e:
                    processing_placeholder.empty()
                    st.error(f"读取数据失败: {str(e)}")
                    st.stop()
                
                # 确保索引有效
                if name_col_index >= len(df_processing.columns) or percentage_col_index >= len(df_processing.columns):
                    processing_placeholder.empty()
                    st.error("选择的列索引超出数据范围！")
                    st.stop()
                
                # 根据索引获取实际的列名
                actual_name_col = df_processing.columns[name_col_index]
                actual_percentage_col = df_processing.columns[percentage_col_index]
                
                imported_count = 0
                skipped_count = 0
                errors = []
                # 统计总行数与已处理行数，用于在循环最后统一渲染结果
                rows_total = len(df_processing)
                rows_processed = 0
                
                # 处理每一行数据
                for index, row in df_processing.iterrows():
                    try:
                        # 获取名称和比例 - 安全转换为字符串
                        try:
                            subsidiary_name = str(row[actual_name_col]).strip()
                        except Exception as e:
                            raise ValueError(f"获取名称失败: {str(e)}")
                        
                        try:
                            percentage_value = row[actual_percentage_col]
                        except Exception as e:
                            raise ValueError(f"获取比例失败: {str(e)}")
                        
                        logger.info(f"处理行 {index+1}: 名称='{subsidiary_name}', 比例值='{percentage_value}'")
                        
                        # 跳过空名称或无效名称
                        if not subsidiary_name or subsidiary_name.lower() in ["nan", "none", "null", "", "-"]:
                            skipped_count += 1
                            continue
                        
                        # 尝试将比例转换为数字
                        percentage = None
                        try:
                            percentage = float(percentage_value)
                            # 确保比例在有效范围内
                            if percentage < 0 or percentage > 100:
                                skipped_count += 1
                                errors.append(f"第{index+1}行: 比例 {percentage} 超出有效范围")
                                continue
                        except (ValueError, TypeError):
                            # 尝试从字符串中提取数字（处理如"30%"这样的值）
                            try:
                                import re
                                num_str = re.search(r'\d+(\.\d+)?', str(percentage_value))
                                if num_str:
                                    percentage = float(num_str.group())
                                    if not (0 <= percentage <= 100):
                                        skipped_count += 1
                                        errors.append(f"第{index+1}行: 提取的比例 {percentage} 超出有效范围")
                                        continue
                                else:
                                    skipped_count += 1
                                    errors.append(f"第{index+1}行: 无法从 '{percentage_value}' 中提取比例")
                                    continue
                            except Exception as e:
                                skipped_count += 1
                                errors.append(f"第{index+1}行: 比例转换失败 - {str(e)}")
                                continue

                        # 检查是否已存在
                        exists = False
                        for i, sub in enumerate(st.session_state.equity_data["subsidiaries"]):
                            if sub.get("name") == subsidiary_name:
                                # 更新现有子公司的百分比
                                st.session_state.equity_data["subsidiaries"][i]["percentage"] = percentage
                                # 同步关系
                                if st.session_state.equity_data.get("core_company"):
                                    for j, rel in enumerate(st.session_state.equity_data["entity_relationships"]):
                                        if rel.get("parent") == st.session_state.equity_data["core_company"] and rel.get("child") == subsidiary_name:
                                            st.session_state.equity_data["entity_relationships"][j]["percentage"] = percentage
                                            break
                                exists = True
                                imported_count += 1
                                break

                        # 如果不存在，新增子公司并自动判定类型
                        if not exists:
                            try:
                                if 'auto_detect_sub_type' in locals() and auto_detect_sub_type:
                                    entity_type_sub = smart_importer_sub.auto_detect_entity_type(subsidiary_name)
                                else:
                                    entity_type_sub = "company"
                            except Exception:
                                entity_type_sub = "company"

                            st.session_state.equity_data["subsidiaries"].append({
                                "name": subsidiary_name,
                                "type": entity_type_sub,
                                "percentage": percentage
                            })

                            # 加入 all_entities
                            if not any(e.get("name") == subsidiary_name for e in st.session_state.equity_data.get("all_entities", [])):
                                st.session_state.equity_data["all_entities"].append({
                                    "name": subsidiary_name,
                                    "type": entity_type_sub
                                })

                            # 与核心公司建立关系
                            if st.session_state.equity_data.get("core_company"):
                                st.session_state.equity_data["entity_relationships"].append({
                                    "parent": st.session_state.equity_data["core_company"],
                                    "child": subsidiary_name,
                                    "percentage": percentage
                                })
                            imported_count += 1

                    except Exception as e:
                        skipped_count += 1
                        errors.append(f"第{index+1}行: 处理失败 - {str(e)}")

                # 循环结束后统一展示导入结果
                try:
                    processing_placeholder.empty()
                except Exception:
                    pass
                st.markdown("### 导入结果")
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("成功导入", imported_count)
                with col2:
                    st.metric("跳过记录", skipped_count)

                if errors:
                    st.warning(f"共 {len(errors)} 条记录处理失败:")
                    with st.expander("查看详细错误信息"):
                        for error in errors:
                            st.code(error)

                if st.button("确认并刷新列表", type="primary", key="subsidiary_import_refresh_final"):
                    st.rerun()
                else:
                    st.info("点击上方按钮刷新列表，查看导入结果")
                                # 尝试从字符串中提取数字
                                num_str = re.search(r'\d+(\.\d+)?', str(percentage_value))
                                if num_str:
                                    percentage = float(num_str.group())
                                    if not (0 <= percentage <= 100):
                                        skipped_count += 1
                                        errors.append(f"第{index+1}行: 提取的比例 {percentage} 超出有效范围")
                                        continue
                                else:
                                    skipped_count += 1
                                    errors.append(f"第{index+1}行: 无法从 '{percentage_value}' 中提取比例")
                                    continue
                            except Exception as e:
                                # 如果无法转换为数字，跳过
                                skipped_count += 1
                                errors.append(f"第{index+1}行: 比例转换失败 - {str(e)}")
                                continue
                            
                            # 检查是否已存在
                            exists = False
                            for i, sub in enumerate(st.session_state.equity_data["subsidiaries"]):
                                if sub["name"] == subsidiary_name:
                                    # 更新现有子公司的百分比
                                    st.session_state.equity_data["subsidiaries"][i]["percentage"] = percentage
                                    
                                    # 更新对应的关系
                                    if st.session_state.equity_data["core_company"]:
                                        for j, rel in enumerate(st.session_state.equity_data["entity_relationships"]):
                                            if rel["parent"] == st.session_state.equity_data["core_company"] and rel["child"] == subsidiary_name:
                                                st.session_state.equity_data["entity_relationships"][j]["percentage"] = percentage
                                                break
                                    
                                    exists = True
                                    imported_count += 1
                                    logger.info(f"第{index+1}行: 更新现有子公司 '{subsidiary_name}' 的比例为 {percentage}%")
                                    break
                            
                            # 如果不存在，添加新子公司
                            if not exists:
                                # 自动判定实体类型（公司/个人）
                                try:
                                    if 'auto_detect_sub_type' in locals() and auto_detect_sub_type:
                                        entity_type_sub = smart_importer_sub.auto_detect_entity_type(subsidiary_name)
                                    else:
                                        entity_type_sub = "company"
                                except Exception:
                                    entity_type_sub = "company"

                                st.session_state.equity_data["subsidiaries"].append({
                                    "name": subsidiary_name,
                                    "type": entity_type_sub,
                                    "percentage": percentage
                                })
